import type { RegexAnalysis, RegexFlags, RegexTestResult } from "@/types/regex"

interface ExportData {
  pattern: string
  flags: RegexFlags
  testString: string
  result: RegexTestResult
  analysis: RegexAnalysis | null
  timestamp: string
}

/**
 * Export regex test results to JSON
 */
export function exportToJSON(data: ExportData): void {
  const exportData = {
    ...data,
    meta: {
      version: "1.0.0",
      exportedAt: new Date().toISOString(),
      tool: "Advanced Regex Tester",
    },
  }

  const blob = new Blob([JSON.stringify(exportData, null, 2)], {
    type: "application/json",
  })

  const url = URL.createObjectURL(blob)
  const link = document.createElement("a")
  link.href = url
  link.download = `regex-test-${Date.now()}.json`
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
  URL.revokeObjectURL(url)
}

/**
 * Export regex test results to CSV
 */
export function exportToCSV(data: ExportData): void {
  const rows = [
    ["Match #", "Match Text", "Start Index", "End Index", "Groups"],
    ...data.result.matches.map((match, index) => [
      (index + 1).toString(),
      match.match,
      match.index.toString(),
      (match.index + match.match.length).toString(),
      match.groups.join("; "),
    ]),
  ]

  const csvContent = rows
    .map((row) => row.map((cell) => `"${cell.replace(/"/g, '""')}"`).join(","))
    .join("\n")

  const blob = new Blob([csvContent], { type: "text/csv" })
  const url = URL.createObjectURL(blob)
  const link = document.createElement("a")
  link.href = url
  link.download = `regex-matches-${Date.now()}.csv`
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
  URL.revokeObjectURL(url)
}

/**
 * Export regex pattern as code snippet
 */
export function exportAsCode(
  data: ExportData,
  language: "javascript" | "python" | "java" | "csharp" = "javascript"
): void {
  const flagString = Object.entries(data.flags)
    .filter(([, value]) => value)
    .map(([key]) => {
      switch (key) {
        case "global":
          return "g"
        case "ignoreCase":
          return "i"
        case "multiline":
          return "m"
        case "dotAll":
          return "s"
        case "unicode":
          return "u"
        case "sticky":
          return "y"
        default:
          return ""
      }
    })
    .join("")

  let code: string
  let filename: string

  switch (language) {
    case "javascript":
      code = `// Regex pattern generated by Advanced Regex Tester
// Pattern: ${data.pattern}
// Flags: ${flagString}
// Test string: ${data.testString.substring(0, 50)}${data.testString.length > 50 ? "..." : ""}

const regex = /${data.pattern}/${flagString};
const testString = \`${data.testString.replace(/`/g, "\\`")}\`;

// Test the pattern
const matches = testString.match(regex);
console.log('Matches:', matches);

// Global matching
const allMatches = [...testString.matchAll(regex)];
console.log('All matches:', allMatches);`
      filename = `regex-pattern-${Date.now()}.js`
      break

    case "python":
      code = `# Regex pattern generated by Advanced Regex Tester
# Pattern: ${data.pattern}
# Flags: ${flagString}
# Test string: ${data.testString.substring(0, 50)}${data.testString.length > 50 ? "..." : ""}

import re

pattern = r'${data.pattern}'
flags = ${getPythonFlags(data.flags)}
test_string = '''${data.testString.replace(/'/g, "\\'")}'''

# Test the pattern
regex = re.compile(pattern, flags)
matches = regex.findall(test_string)
print('Matches:', matches)

# Find all matches with positions
all_matches = list(regex.finditer(test_string))
for i, match in enumerate(all_matches):
    print(f'Match {i+1}: {match.group()} at position {match.start()}-{match.end()}')`
      filename = `regex-pattern-${Date.now()}.py`
      break

    case "java":
      code = `// Regex pattern generated by Advanced Regex Tester
// Pattern: ${data.pattern}
// Flags: ${flagString}
// Test string: ${data.testString.substring(0, 50)}${data.testString.length > 50 ? "..." : ""}

import java.util.regex.Pattern;
import java.util.regex.Matcher;

public class RegexTest {
    public static void main(String[] args) {
        String pattern = "${data.pattern.replace(/\\/g, "\\\\")}";
        ${getJavaFlags(data.flags)}
        String testString = "${data.testString.replace(/"/g, '\\"').replace(/\n/g, "\\n")}";

        Pattern regex = Pattern.compile(pattern${getJavaFlags(data.flags) ? ", flags" : ""});
        Matcher matcher = regex.matcher(testString);

        System.out.println("Matches:");
        int matchCount = 0;
        while (matcher.find()) {
            matchCount++;
            System.out.println("Match " + matchCount + ": " + matcher.group() +
                             " at position " + matcher.start() + "-" + matcher.end());
        }
    }
}`
      filename = `RegexTest-${Date.now()}.java`
      break

    case "csharp":
      code = `// Regex pattern generated by Advanced Regex Tester
// Pattern: ${data.pattern}
// Flags: ${flagString}
// Test string: ${data.testString.substring(0, 50)}${data.testString.length > 50 ? "..." : ""}

using System;
using System.Text.RegularExpressions;

class Program
{
    static void Main()
    {
        string pattern = @"${data.pattern.replace(/\\/g, "\\\\")}";
        RegexOptions options = ${getCSharpFlags(data.flags)};
        string testString = @"${data.testString.replace(/"/g, '""')}";

        Regex regex = new Regex(pattern, options);
        MatchCollection matches = regex.Matches(testString);

        Console.WriteLine("Matches:");
        for (int i = 0; i < matches.Count; i++)
        {
            Match match = matches[i];
            Console.WriteLine($"Match {i + 1}: {match.Value} at position {match.Index}-{match.Index + match.Length}");
        }
    }
}`
      filename = `RegexTest-${Date.now()}.cs`
      break

    default:
      throw new Error(`Unsupported language: ${language}`)
  }

  const blob = new Blob([code], { type: "text/plain" })
  const url = URL.createObjectURL(blob)
  const link = document.createElement("a")
  link.href = url
  link.download = filename
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
  URL.revokeObjectURL(url)
}

function getPythonFlags(flags: RegexFlags): string {
  const pythonFlags: string[] = []
  if (flags.ignoreCase) pythonFlags.push("re.IGNORECASE")
  if (flags.multiline) pythonFlags.push("re.MULTILINE")
  if (flags.dotAll) pythonFlags.push("re.DOTALL")
  return pythonFlags.length > 0 ? pythonFlags.join(" | ") : "0"
}

function getJavaFlags(flags: RegexFlags): string | null {
  const javaFlags: string[] = []
  if (flags.ignoreCase) javaFlags.push("Pattern.CASE_INSENSITIVE")
  if (flags.multiline) javaFlags.push("Pattern.MULTILINE")
  if (flags.dotAll) javaFlags.push("Pattern.DOTALL")
  if (flags.unicode) javaFlags.push("Pattern.UNICODE_CASE")

  if (javaFlags.length === 0) return null
  return `int flags = ${javaFlags.join(" | ")};`
}

function getCSharpFlags(flags: RegexFlags): string {
  const csharpFlags: string[] = []
  if (flags.ignoreCase) csharpFlags.push("RegexOptions.IgnoreCase")
  if (flags.multiline) csharpFlags.push("RegexOptions.Multiline")
  if (flags.dotAll) csharpFlags.push("RegexOptions.Singleline")
  return csharpFlags.length > 0 ? csharpFlags.join(" | ") : "RegexOptions.None"
}

/**
 * Generate shareable URL
 */
export function generateShareableURL(
  data: Pick<ExportData, "pattern" | "flags" | "testString">
): string {
  const params = new URLSearchParams()
  params.set("pattern", data.pattern)
  params.set("testString", data.testString)

  Object.entries(data.flags).forEach(([key, value]) => {
    if (value) params.set(key, "true")
  })

  return `${window.location.origin}/regex-tester?${params.toString()}`
}

/**
 * Copy text to clipboard
 */
export async function copyToClipboard(text: string): Promise<boolean> {
  try {
    await navigator.clipboard.writeText(text)
    return true
  } catch (error) {
    // Fallback for older browsers
    const textArea = document.createElement("textarea")
    textArea.value = text
    textArea.style.position = "fixed"
    textArea.style.left = "-999999px"
    textArea.style.top = "-999999px"
    document.body.appendChild(textArea)
    textArea.focus()
    textArea.select()

    try {
      document.execCommand("copy")
      document.body.removeChild(textArea)
      return true
    } catch (fallbackError) {
      document.body.removeChild(textArea)
      return false
    }
  }
}
